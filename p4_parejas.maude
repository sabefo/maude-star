fmod TABLAHASH is
 pr NAT .
 sorts IdNodo Tablahash .

 op Id_ : Nat -> IdNodo [ctor] . *** Constructor de IdNodo
 op tv : Tablahash . *** Tabla vacia
 op [_,_] : IdNodo Nat -> Tablahash [ctor] .
 op _ _ : Tablahash Tablahash -> Tablahash [ctor id: tv] .

endfm

fmod RED is
 pr NAT .
 pr TABLAHASH .

 var S : Sistema .
 var L : Localizacion .

 sorts Localizacion Sistema Contenidos Nodo Msj Socket ListaMsj Id ListaIds .
 subsort Localizacion Socket < Sistema .

 *** Definición de lista de ids de amigos
 subsort Id < ListaIds .
 op _._ : ListaIds ListaIds -> ListaIds [ctor assoc] .

 *** Define los subtipos entre Contenidos y Nodo y Msj
 subsort Msj Nodo < Contenidos .
 op __ : Contenidos Contenidos -> Contenidos [ctor assoc comm] .

 *** Define los subtipos entre Msj y ListaMsj
 subsort Msj < ListaMsj .
 op _,_ : ListaMsj ListaMsj -> ListaMsj [ctor assoc] .

 op info : Nat Nat IdNodo -> Msj [ctor] .
 op respuesta-info : IdNodo -> Msj [ctor] .
 op to_:_ : IdNodo String -> Msj [ctor] .
 op numNodos : Sistema -> Nat .
 eq numNodos(L S) = numNodos(S) + 1 .
 eq numNodos(S) = 0 [owise] .

 op none : -> Sistema [ctor] .
 op {_|_} : Nat Contenidos -> Localizacion [ctor] .
 op __ : Sistema Sistema -> Sistema [ctor assoc comm id: none] .

 op <_|_;_|_> : Nat ListaMsj ListaMsj Nat -> Socket [ctor] .

 *** Termina de definir constructores

 op idNodo : Nat -> Id .
 idNodo(a)

 *** Nat es un estado, en el extremo puede ser INACTIVO, ACTIVO y ESPERANDO, en el centro puede ser ACTIVO e INACTIVO
 op extremo : Id Nat Nat ListaIds String -> Nodo .
 op centro : Id Tabla Nat -> Nodo .
endfm

mod COMPORTAMIENTO is
 *** Importa los modulos correspondientes
 pr RED .
 *** Define el comportamiento de la red mediante reglas
 *** Estados de los mensajes 0 esperando 1 activo 2 inactivo
 *** ----Cuando un mensaje va dirigido a un nodo en otra localización tenemos las siguientes opciones:
 *** ----Los extremos mandan su mensaje al centro a través del socket correspondiente (introduciéndolo en la lista adecuada).
 rl [mensaje-otra-loc-extremo] : { j | Msj } extremo(Id, N, N', L, S) => <i | Li ; { j | Msj } | j> .

 *** ----El centro usa su tabla hash para enviar el mensaje a la localización correcta a través del socket correspondiente.
 rl [mensaje-otra-loc-centro] : { j | Msj } centro(Id, [j, N'] T, N) => <i | Li ; { j | Msj } | j> .

 *** ----Cuando tenemos un mensaje al principio de la lista del socket, entonces lo movemos a la Localizacion correspondiente.
 rl [principio-socket] : { j | C } <i | Li ; (Lj,Msj) | j> => { j | Msj C } <i | Li ; Lj | j> .

 rl [info-en-socket] : { N' | info(N, N', Id) extremo(Id, 0, N, L, S) } < N' | Li ; Lj | N >
      => {N' | extremo(Id, 0, N, L, S)} < N' | Li ; (info(N, N', Id), Lj) | N > .

 rl [respuesta-en-socket] : { N' | respuesta-info(Id) centro(Id, T, N) } < N' | Li ; Lj | N >
      => { N' | centro(Id, T, N) } < N' | Li ; (extremo(Id, 0, N, L, S), Lj) | N > .

 *** ----El mensaje info lo envían los extremos en estado inactivo para indicar su dirección y su nombre. Al enviarlo pasa al estado esperando.
 rl [extremo-inactivo] : {N' | extremo(Id, 2, N, L, S)} => {N' | info(N, N', Id) extremo(Id, 0, N, L, S)} .

 *** ----Este mensaje es recibido por el centro y se utiliza para actualizar la tabla.
 *** ----En la misma regla el centro envía respuesta-info al extremo como respuesta.
 rl [centro-tabla] : {N | info(N, N', Id) centro(Id, T, N'')} => {N | respuesta-info(Id) centro(Id, [Id, N] T, 1)} .

 *** ----Los nodos con amigos mandan un mensaje de la forma to_:_ a dichos amigos diciéndoles "hola". Asegúrate de que solo manden uno de estos mensajes a cada amigo (es válido borrar amigos de la lista).
 rl [nodo-extremo-amigos] : extremo(Id, N, N', Id' . L, S) => Id' : "hola" extremo(Id, N, N', L, S) .

 *** ----Cuando un extremo recibe el mensaje respuesta-info actualiza su estado y pasa a activo.
 rl [extremo-respuesta-info] : extremo(Id, N, N', L, S) => extremo(Id, 1, N', L, S) .

 *** ----Cuando un mensaje to_:_ llega a un nodo el mensaje se concatena a lo que ya habíamos recibido.
 rl [to-nodo] : { N | IdNodo : S centro(Id, [IdNodo, N'] T, N) } <N | LN ; LN' | N'>
 	=> {N | centro(Id, [IdNodo, N'] T, N) } <N | { N | IdNodo } ; LN' | N'> .
 rl [to-nodo] : IdNodo : S extremo(Id, N, N', L, S') => extremo(Id, N, N', L, S + S') .

endm

mod EJEMPLO is
 *** Importa los modulos correspondientes
pr RED
pr COMPORTAMIENTO

 op init : -> Sistema .
 *** Define un término inicial sobre el que probar las propiedades siguiendo el enunciado
 red init = { 0 | tv , 2 } *** Dentro habrá un nodo
            { 1 | 1 , 0, [2, 3, 4], 2, "a" }
            { 2 | 2 , 0, [1, 3, 4], 2, "la" }
            { 3 | 3 , 0, [1, 2, 4], 2 , "verga" }
            { 4 | 4 , 0, [1, 2, 3], 2 , "Msj" }
            < 0 | ... ; ... | 1 >
*** Socket que une 0 y 1. Los puntos suspensivos serán listas vacías
endm

rew init .

*** search init ...

load model-checker

mod PROPS is
 *** Importa los modulos correspondientes

 *** Define las propiedades
endm

mod TEST is
 *** Importa los modulos correspondientes
endm

eof

*** Define y comprueba las propiedades

red modelCheck(init, ...) .
