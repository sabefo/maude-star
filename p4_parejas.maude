fmod TABLAHASH is
 pr NAT .
 sorts IdNodo Tablahash .

 op Id_ : Nat -> IdNodo [ctor] . *** Constructor de IdNodo
 op tv : Tablahash . *** Tabla vacia
 op [_,_] : IdNodo Nat -> Tablahash [ctor] .
 op _ _ : Tablahash Tablahash -> Tablahash [ctor id: tv] .

endfm

fmod RED is
 pr NAT .
 pr TABLAHASH .

 var S : Sistema .
 var L : Localizacion .

 sorts Localizacion Sistema Contenidos Nodo Msj Socket ListaMsj Id .
 subsort Localizacion Socket < Sistema .
 

 *** Define los subtipos entre Contenidos y Nodo y Msj
 subsort Msj Nodo < Contenidos .
 op __ : Contenidos Contenidos -> Contenidos [ctor assoc comm] .
  
 *** Define los subtipos entre Msj y ListaMsj
 subsort Msj < ListaMsj .
 op _,_ : ListaMsj ListaMsj -> ListaMsj [ctor assoc] .

 op info : Nat Nat IdNodo -> Msj [ctor] .
 op respuesta-info : IdNodo -> Msj [ctor] .
 op to_:_ : IdNodo String -> Msj [ctor] .
 op numNodos : Sistema -> Nat .
 eq numNodos(L S) = numNodos(S) + 1 .
 eq numNodos(S) = 0 [owise] .

 op none : -> Sistema [ctor] .
 op {_|_} : Nat Contenidos -> Localizacion [ctor] .
 op __ : Sistema Sistema -> Sistema [ctor assoc comm id: none] .

 op <_|_;_|_> : Nat ListaMsj ListaMsj Nat -> Socket [ctor] .

 *** Termina de definir constructores

 op idNodo : String -> Id .
 idNodo("a")

 *** Nat es un estado, en el extremo puede ser INACTIVO, ACTIVO y ESPERANDO, en el centro puede ser ACTIVO e INACTIVO
 op extremo : Id Nat Nat ListaIds String -> Nodo .
 op centro : Id Tabla Nat -> Nodo .
endfm

mod COMPORTAMIENTO is
 *** Importa los modulos correspondientes
 pr RED .

 *** queda definir estados de los mensajes 0 esperando 1 activo 2 inactivo
 *** ----Cuando un mensaje va dirigido a un nodo en otra localización tenemos las siguientes opciones:
 *** ----Los extremos mandan su mensaje al centro a través del socket correspondiente (introduciéndolo en la lista adecuada).
 rl[mensaje-otra-loc-extremo] : { j | Msj } extremo(Id, N, N', L, S) => <i | Li ; { j | Msj } | j> .
 
 *** ----El centro usa su tabla hash para enviar el mensaje a la localización correcta a través del socket correspondiente.
 rl[mensaje-otra-loc-centro] : {j | Msj } centro(Id, [j, N'] T, N) => <i | Li ; Lj | j> .


 *** ----Cuando tenemos un mensaje al principio de la lista del socket, entonces lo movemos a la Localizacion correspondiente.
 rl[principio-socket] : { j | C } <i | Li ; Msj Lj | j> => { j | Msj C } <i | Li ; Lj | j> .

 *** ------------------------------
 *** rl[principio-socket] : { j | C } <i | Li ; Msj Lj | j> => { j | Msj C } <i | Li ; Lj | j> .
 *** ------------------------------

 *** ----El mensaje info lo envían los extremos en estado inactivo para indicar su dirección y su
nombre. Al enviarlo pasa al estado esperando.
 rl[extremo-inactivo] : {N' | extremo(Id, 2, N, L, S)} => {N' | info(N, N', Id) extremo(Id, 0, N, L, S)} .

 *** ----Este mensaje es recibido por el centro y se utiliza para actualizar la tabla.
 *** ----En la misma regla el centro envía respuesta-info al extremo como respuesta.
 rl[centro-tabla] : {N | info(N, N', Id) centro(Id, T, N'')} => {N | respuesta-info(Id) centro(Id, [Id, N] T, 1)} .

 *** ----Cuando un extremo recibe el mensaje respuesta-info actualiza su estado y pasa a activo.
 rl[extremo-respuesta-info] : extremo(Id, N, N', L, S) => extremo(Id, 1, N', L, S) .

 *** ----Cuando un mensaje to_:_ llega a un nodo el mensaje se concatena a lo que ya habíamos recibido.
 rl[to-nodo] : {N | IdNodo : S centro(Id, [IdNodo, N'] T, N) } <N | LN ; LN' | N'>
 	=> {N | centro(Id, [IdNodo, N'] T, N) } <N | { N | IdNodo } ; LN' | N'> .
 rl[to-nodo] : IdNodo : S extremo(Id, N, N', L, S') => extremo(Id, N, N', L, S + S') .

 *** Define el comportamiento de la red mediante reglas
endm

mod EJEMPLO is
 *** Importa los modulos correspondientes

 op init : -> Sistema .
 *** Define un término inicial sobre el que probar las propiedades siguiendo el enunciado
 *** red init = { 0 | ... } *** Dentro habrá un nodo
 ***            { 1 | ... }
 ***            ...
 ***            < 0 | ... ; ... | 1 > *** Socket que une 0 y 1. Los puntos suspensivos serán listas vacías
endm

rew init .

*** search init ...

load model-checker

mod PROPS is
 *** Importa los modulos correspondientes

 *** Define las propiedades
endm

mod TEST is
 *** Importa los modulos correspondientes
endm

eof

*** Define y comprueba las propiedades

red modelCheck(init, ...) .